% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jsonrepair.R
\name{JSONParser}
\alias{JSONParser}
\title{JSONParser}
\description{
Internal JSON parser class for incremental parsing of JSON strings
}
\details{
This R6 class implements a streaming JSON parser that can handle incomplete
or streaming JSON data. It maintains parsing state through an index position and
context stack, allowing for incremental parsing and handling of multiple JSON
objects in a single string. The parser supports logging for debugging purposes
and can detect duplicate objects during streaming operations.
}
\section{Methods}{

\describe{
\item{\code{initialize(json_str, logging = FALSE, stream_stable = FALSE)}}{
Constructor to create a new JSONParser instance.
\code{json_str}: JSON string to parse
\code{logging}: Enable logging for debugging
\code{stream_stable}: Enable stream stability mode
}
\item{\code{parse()}}{
Main parsing function that processes the JSON string from the current index position.
Handles multiple JSON objects in a single string and removes duplicates when detected.
Returns the parsed JSON object(s), or a list containing both the result and logs if logging is enabled.
}
}
}

\section{Parsing Logic}{

The method follows a specific decision tree:
\enumerate{
\item \strong{End of Input}: When no more characters are available, returns empty string
\item \strong{Object Detection}: When encountering '{', delegates to \code{parse_object()}
\item \strong{Array Detection}: When encountering '[', delegates to \code{parse_array()}
\item \strong{Edge Case Handling}: Manages malformed JSON scenarios like missing values
}
}

\section{Context Awareness}{

The method is context-aware and behaves differently based on the current parsing state:
\itemize{
\item \strong{OBJECT_VALUE context}: Special handling for missing values when '}' is encountered
\item \strong{General parsing}: Standard object and array detection
\item \strong{Stream stability}: Maintains state for continuous parsing operations
}
}

\section{Error Recovery}{

Implements graceful error recovery for common JSON malformation issues:
\itemize{
\item Missing values in object properties
\item Incomplete JSON structures in streaming scenarios
\item Unexpected end-of-input conditions
}
}

\examples{
\dontrun{
# Basic parsing
parser <- JSONParser$new('{"key": "value"}')
result <- parser$parse()

# Parsing with logging
parser <- JSONParser$new('{"key": "value"}', logging = TRUE)
result_with_logs <- parser$parse()

# Streaming mode
parser <- JSONParser$new('{"a": 1}{"b": 2}', stream_stable = TRUE)
result <- parser$parse()  # Returns list of objects
}
}
\keyword{Internal}
\keyword{Skip}
\keyword{characters}
\keyword{context}
\keyword{from}
\keyword{function}
\keyword{internal}
\keyword{logging}
\keyword{position}
\keyword{specified}
\keyword{starting}
\keyword{whitespace}
\keyword{window}
\keyword{with}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{json_str}}{Character string containing the JSON data to parse}

\item{\code{index}}{Integer position of the current parsing location in the JSON string}

\item{\code{context}}{JsonContext object managing the parsing context stack}

\item{\code{logging}}{Logical flag indicating whether to enable parsing logs}

\item{\code{logger}}{List storing log messages when logging is enabled}

\item{\code{stream_stable}}{Logical flag for streaming stability mode}

\item{\code{log}}{Function for logging (no-op when logging disabled)}

\item{\code{NUMBER_CHARS}}{Character vector of valid numeric characters including operators}

\item{\code{STRING_DELIMITERS}}{Character vector of valid string delimiter characters}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-JSONParser-new}{\code{JSONParser$new()}}
\item \href{#method-JSONParser-parse}{\code{JSONParser$parse()}}
\item \href{#method-JSONParser-parse_json}{\code{JSONParser$parse_json()}}
\item \href{#method-JSONParser-parse_object}{\code{JSONParser$parse_object()}}
\item \href{#method-JSONParser-parse_array}{\code{JSONParser$parse_array()}}
\item \href{#method-JSONParser-parse_string}{\code{JSONParser$parse_string()}}
\item \href{#method-JSONParser-parse_number}{\code{JSONParser$parse_number()}}
\item \href{#method-JSONParser-parse_boolean_or_null}{\code{JSONParser$parse_boolean_or_null()}}
\item \href{#method-JSONParser-parse_comment}{\code{JSONParser$parse_comment()}}
\item \href{#method-JSONParser-get_char_at}{\code{JSONParser$get_char_at()}}
\item \href{#method-JSONParser-skip_whitespaces_at}{\code{JSONParser$skip_whitespaces_at()}}
\item \href{#method-JSONParser-skip_to_character}{\code{JSONParser$skip_to_character()}}
\item \href{#method-JSONParser-.log}{\code{JSONParser$.log()}}
\item \href{#method-JSONParser-clone}{\code{JSONParser$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-new"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-new}{}}}
\subsection{Method \code{new()}}{
Initialize a new JSONParser instance
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$new(json_str, logging = FALSE, stream_stable = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{json_str}}{Character string containing JSON data to parse}

\item{\code{logging}}{Logical flag to enable debug logging (default: FALSE)}

\item{\code{stream_stable}}{Logical flag for streaming stability mode (default: FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new JSONParser object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-parse"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-parse}{}}}
\subsection{Method \code{parse()}}{
Main parse function that processes JSON string and handles multiple objects
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$parse()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Parsed JSON object(s). If logging enabled, returns list with result and logs.
For multiple objects, returns a list unless they are duplicates.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-parse_json"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-parse_json}{}}}
\subsection{Method \code{parse_json()}}{
Main JSON parsing dispatcher method
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$parse_json()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This is the core parsing method that determines the type of JSON element
at the current parsing position and delegates to the appropriate specialized
parsing method. It handles the main JSON data types: objects, arrays, and
special edge cases for malformed JSON.

The method operates in a loop, examining each character to determine the
JSON structure type. It maintains parsing state through the context stack
and handles various edge cases that may occur in streaming or malformed JSON.
}

\subsection{Returns}{
The parsed JSON element:
\itemize{
\item For objects: Result from \code{parse_object()}
\item For arrays: Result from \code{parse_array()}
\item For end-of-input: Empty string \code{""}
\item For missing values in objects: Empty string \code{""} with warning log
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-parse_object"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-parse_object}{}}}
\subsection{Method \code{parse_object()}}{
Parse a JSON object into an R named list
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$parse_object()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method handles the parsing of JSON objects (denoted by curly braces {})
into R named lists. It processes key-value pairs sequentially, handling various
edge cases and malformed JSON scenarios that may occur in streaming or real-world
data. The method maintains robust error recovery and context awareness throughout
the parsing process.

The parser assumes the opening '{' has already been consumed and focuses on
parsing the object contents until the closing '}' is encountered or end-of-input
is reached. It handles whitespace normalization, key parsing, value parsing,
and various JSON formatting irregularities.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-parse_array"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-parse_array}{}}}
\subsection{Method \code{parse_array()}}{
Parse a JSON array into an R list
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$parse_array()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method handles the parsing of JSON arrays (denoted by square brackets [])
into R lists. It processes array elements sequentially, maintaining proper context
and handling various edge cases including nested structures, mixed data types,
and malformed array syntax. The parser supports both complete and streaming
array parsing scenarios.

The parser assumes the opening '\link[=' has already been consumed and focuses on
  parsing array elements until the closing ']{' has already been consumed and focuses on parsing array elements until the closing '}' is encountered or end-of-input
is reached. It handles element separation, whitespace normalization, and
graceful error recovery for malformed arrays.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-parse_string"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-parse_string}{}}}
\subsection{Method \code{parse_string()}}{
Parse a JSON string value with flexible quote handling
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$parse_string()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method handles the parsing of JSON string values, including various
quote styles and edge cases. It manages missing quotes, doubled quotes, comments,
and literal values. This function resolves many weird cases in invalid JSON.
}

\subsection{Returns}{
A character string containing the parsed value. Returns empty string
for malformed or empty strings.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-parse_number"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-parse_number}{}}}
\subsection{Method \code{parse_number()}}{
Parse a JSON number value into R numeric type
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$parse_number()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method handles the parsing of JSON number values in various formats
including integers, decimals, scientific notation, and negative numbers. It
provides context-aware parsing that handles array boundaries properly.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-parse_boolean_or_null"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-parse_boolean_or_null}{}}}
\subsection{Method \code{parse_boolean_or_null()}}{
Parse JSON boolean or null literal values
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$parse_boolean_or_null()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method handles the parsing of JSON literal values: 'true', 'false',
and 'null' (unquoted). It performs case-insensitive matching and provides
rollback functionality for failed matches.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-parse_comment"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-parse_comment}{}}}
\subsection{Method \code{parse_comment()}}{
Parse and skip code-like comments in JSON
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$parse_comment()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This method handles parsing of various comment formats that may appear
in non-standard JSON. Comments are skipped entirely and do not interfere with
JSON parsing. Supports context-aware termination based on current parsing state.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-get_char_at"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-get_char_at}{}}}
\subsection{Method \code{get_char_at()}}{
Get character at specified position relative to current index
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$get_char_at(count = 0L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{count}}{Integer. The position to get character from}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-skip_whitespaces_at"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-skip_whitespaces_at}{}}}
\subsection{Method \code{skip_whitespaces_at()}}{
Skip whitespace characters starting from specified position
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$skip_whitespaces_at(idx = 0L, move_main_index = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{idx}}{Integer. The index position to start skipping whitespaces}

\item{\code{move_main_index}}{Logical. Whether to move the main index pointer}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Efficiently skips over whitespace characters (spaces, tabs, newlines, etc.)
starting from the calculated position. Can operate in two modes: updating the
main parsing index or performing lookahead without affecting main position.
}

\subsection{Returns}{
Integer. The updated index position
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-skip_to_character"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-skip_to_character}{}}}
\subsection{Method \code{skip_to_character()}}{
Search for a target character starting from specified offset
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$skip_to_character(character, idx = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{character}}{Character. The target character to skip to}

\item{\code{idx}}{Integer. Starting index position}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Safely searches forward through the JSON string to find the next
occurrence of the specified character. Includes error handling for
bounds violations and empty character scenarios.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-.log"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-.log}{}}}
\subsection{Method \code{.log()}}{
Internal logging function with context window
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$.log(text)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{text}}{Character. The text message to log}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Creates detailed log entries that include both the log message
and a context window showing surrounding characters from the JSON string.
The context window helps with debugging by showing the parsing environment.
}

\subsection{Returns}{
NULL (invisible, called for side effects)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-JSONParser-clone"></a>}}
\if{latex}{\out{\hypertarget{method-JSONParser-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{JSONParser$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
